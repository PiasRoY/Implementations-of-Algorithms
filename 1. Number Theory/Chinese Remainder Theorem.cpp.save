ll inv(ll a, ll m)
{
    ll m0 = m, t, q;
    ll x0 = 0, x1 = 1;

    if (m == 1)
       return 0;

    while (a > 1)
    {
        q = a / m;
        t = m;
        m = a % m, a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0)
       x1 += m0;

    return x1;
}

ll CRT(vector<ll>num, vector<ll>rem, ll k)
{
    ll prod = 1;
    for (ll i = 0; i < k; i++)
        prod *= num[i];

    ll result = 0;

    for (ll i = 0; i < k; i++)
    {
        ll pp = prod / num[i];
        result += rem[i] * inv(pp, num[i]) * pp;
    }

    return result % prod;
}

//CF implement
int extended_gcd(int a, int b, int & x, int & y) {
	if(a == 0) {
		x = 0;
		y = 1;
		return b;
	}

	int x1, y1, gcd;
	gcd = extended_gcd(b%a, a, x1, y1);
	x = y1 - (b/a) * x1;
	y = x1;

	return gcd;
}

int normalize(int x, int mod)
{
    x %= mod;
    return (x<0) ? x+=mod : x;
}

void solve()
{
    int m
    scanf("%d", &m);
    for(int i = 1; i <= m; i++) {
        scanf("%d %d", &a[i], &n[i]);
        normalize(a[i], n[i]);
    }

    ans = a[1];
    lcm = n[1];
    for(int i = 2; i <= t; i++)
    {
        auto pom = ex_GCD(lcm, n[i]);
        int x1 = pom.x;
        int d = pom.d;
        if((a[i] - ans) % d != 0) return cerr << "No solutions" << endl, 0;
        ans = normalize(ans + x1 * (a[i] - ans) / d % (n[i] / d) * lcm, lcm * n[i] / d);
        lcm = LCM(lcm, n[i]); // you can save time by replacing above lcm * n[i] /d by lcm = lcm * n[i] / d
    }
    cout << ans << " " << lcm << endl;
}


